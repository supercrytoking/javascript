{"version":3,"sources":["crypto/modules/node.js"],"names":["NodeCryptography","key","input","bKey","getKey","Buffer","encryptBuffer","Readable","encryptStream","encryptString","Error","decryptBuffer","decryptStream","decryptString","file","File","data","name","mimeType","create","stream","sha","update","from","digest","slice","IV_LENGTH","plaintext","bIv","getIv","bPlaintext","aes","algo","concat","toString","sCiphertext","ciphertext","bCiphertext","output","PassThrough","write","pipe","alloc","read","bChunk","sliceLen","byteLength","on","end"],"mappings":"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","sourcesContent":["/** @flow */\nimport { Readable, PassThrough } from 'stream';\nimport { createCipheriv, createDecipheriv, createHash, randomBytes } from 'crypto';\n\nimport type { ICryptography } from '../';\nimport type { IFile, FileClass } from '../../file';\n\nexport default class NodeCryptography implements ICryptography<Buffer | Readable | string> {\n  static IV_LENGTH = 16;\n\n  get algo() {\n    return 'aes-256-cbc';\n  }\n\n  async encrypt(key: string, input: Buffer | Readable | string): Promise<Buffer | Readable | string> {\n    const bKey = this.getKey(key);\n    if (input instanceof Buffer) {\n      return this.encryptBuffer(bKey, input);\n    } else if (input instanceof Readable) {\n      return this.encryptStream(bKey, input);\n    } else if (typeof input === 'string') {\n      return this.encryptString(bKey, input);\n    } else {\n      throw new Error('Unsupported input format');\n    }\n  }\n\n  async decrypt(key: string, input: Buffer | Readable | string): Promise<Buffer | Readable | string> {\n    const bKey = this.getKey(key);\n    if (input instanceof Buffer) {\n      return this.decryptBuffer(bKey, input);\n    } else if (input instanceof Readable) {\n      return this.decryptStream(bKey, input);\n    } else if (typeof input === 'string') {\n      return this.decryptString(bKey, input);\n    } else {\n      throw new Error('Unsupported input format');\n    }\n  }\n\n  async encryptFile(key: string, file: IFile, File: FileClass): Promise<IFile> {\n    const bKey = this.getKey(key);\n\n    if (file.data instanceof Buffer) {\n      return File.create({\n        name: file.name,\n        mimeType: 'application/octet-stream',\n        data: await this.encryptBuffer(bKey, file.data),\n      });\n    } else if (file.data instanceof Readable) {\n      return File.create({\n        name: file.name,\n        mimeType: 'application/octet-stream',\n        stream: await this.encryptStream(bKey, file.data),\n      });\n    } else {\n      throw new Error('Cannot encrypt this file. In Node.js file encryption supports only string, Buffer or Stream.');\n    }\n  }\n\n  async decryptFile(key: string, file: IFile, File: FileClass): Promise<IFile> {\n    const bKey = this.getKey(key);\n\n    if (file.data instanceof Buffer) {\n      return File.create({\n        name: file.name,\n        data: await this.decryptBuffer(bKey, file.data),\n      });\n    } else if (file.data instanceof Readable) {\n      return File.create({\n        name: file.name,\n        stream: await this.decryptStream(bKey, file.data),\n      });\n    } else {\n      throw new Error('Cannot decrypt this file. In Node.js file decryption supports only string, Buffer or Stream.');\n    }\n  }\n\n  getKey(key: string): Buffer {\n    const sha = createHash('sha256');\n\n    sha.update(Buffer.from(key, 'utf8'));\n\n    return Buffer.from(sha.digest('hex').slice(0, 32), 'utf8');\n  }\n\n  getIv(): Buffer {\n    return randomBytes(NodeCryptography.IV_LENGTH);\n  }\n\n  encryptString(key: Buffer, plaintext: string): string {\n    const bIv = this.getIv();\n\n    const bPlaintext = Buffer.from(plaintext);\n\n    const aes = createCipheriv(this.algo, key, bIv);\n\n    return Buffer.concat([bIv, aes.update(bPlaintext), aes.final()]).toString('utf8');\n  }\n\n  decryptString(key: Buffer, sCiphertext: string): string {\n    const ciphertext = Buffer.from(sCiphertext);\n    const bIv = ciphertext.slice(0, NodeCryptography.IV_LENGTH);\n    const bCiphertext = ciphertext.slice(NodeCryptography.IV_LENGTH);\n\n    const aes = createDecipheriv(this.algo, key, bIv);\n\n    return Buffer.concat([aes.update(bCiphertext), aes.final()]).toString('utf8');\n  }\n\n  encryptBuffer(key: Buffer, plaintext: Buffer): Buffer {\n    const bIv = this.getIv();\n\n    const aes = createCipheriv(this.algo, key, bIv);\n\n    return Buffer.concat([bIv, aes.update(plaintext), aes.final()]);\n  }\n\n  decryptBuffer(key: Buffer, ciphertext: Buffer): Buffer {\n    const bIv = ciphertext.slice(0, NodeCryptography.IV_LENGTH);\n    const bCiphertext = ciphertext.slice(NodeCryptography.IV_LENGTH);\n\n    const aes = createDecipheriv(this.algo, key, bIv);\n\n    return Buffer.concat([aes.update(bCiphertext), aes.final()]);\n  }\n\n  encryptStream(key: Buffer, stream: Readable): Readable {\n    const output = new PassThrough();\n    const bIv = this.getIv();\n\n    const aes = createCipheriv(this.algo, key, bIv);\n\n    output.write(bIv);\n    stream.pipe(aes).pipe(output);\n\n    return output;\n  }\n\n  decryptStream(key: Buffer, stream: Readable): Readable {\n    const output = new PassThrough();\n\n    let bIv = Buffer.alloc(0);\n    let aes = null;\n\n    const getIv = () => {\n      let data = stream.read();\n\n      while (data !== null) {\n        if (data) {\n          let bChunk = Buffer.from(data);\n          let sliceLen = NodeCryptography.IV_LENGTH - bIv.byteLength;\n\n          if (bChunk.byteLength < sliceLen) {\n            bIv = Buffer.concat([bIv, bChunk]);\n          } else {\n            bIv = Buffer.concat([bIv, bChunk.slice(0, sliceLen)]);\n\n            aes = createDecipheriv(this.algo, key, bIv);\n\n            aes.pipe(output);\n\n            aes.write(bChunk.slice(sliceLen));\n          }\n        }\n\n        data = stream.read();\n      }\n    };\n\n    stream.on('readable', getIv);\n\n    stream.on('end', () => {\n      if (aes) {\n        aes.end();\n      }\n\n      output.end();\n    });\n\n    return output;\n  }\n}\n"],"file":"node.js"}