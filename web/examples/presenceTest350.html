<html>
<script>

var testInProgress = true;
var testInProgressInterval = 0;
var pnLoading = true;
var channelA = "gecA";
var channelB = "gecB";

var listenerInit = "";
var randomSuffix = "";
var currentTest = "";
var currentStep = "";
var ssl = false;
var clientLevel = "";
var serverLevel = "";

var pubKey = "";
var subKey = "";

var listenerUUID = "PN_LISTENER";
var actorUUID = "PN_ACTOR";

var pnLoadedInterval = "";
var listener = "";
var actor = "";
var extraCompat = "";


var keysets = {

    "keyset1": {
        "pubKey": "pub-c-fb5fa283-0d93-424f-bf86-d9aca2366c86",
        "subKey": "sub-c-d247d250-9dbd-11e3-8008-02ee2ddab7fe",
        "secKey": "sec-c-MmI2YjRjODAtNWU5My00ZmZjLTg0MzUtZGM1NGExNjJkNjg1",
        "description": "Compatibility Mode ON"
    },

    "keyset2": {
        "pubKey": "pub-c-c9b0fe21-4ae1-433b-b766-62667cee65ef",
        "subKey": "sub-c-d91ee366-9dbd-11e3-a759-02ee2ddab7fe",
        "secKey": "sec-c-ZDUxZGEyNmItZjY4Ny00MjJmLWE0MjQtZTQyMDM0NTY2MDVk",
        "description": "Compatibility Mode OFF"
    }
};

var tests = {

    "35_35_SSL_OFF": {

        "common": {
            "description": "3.5 -> 3.5 Base Compatibility, SSL Off.",
            "client": "3.5",
            "server": "3.5",
            "keyset": keysets.keyset1,
            "ssl": false,
            "maxSteps": 3
        },

        "init": {
            "listener": ["subscribe", [channelA, channelB], 0]
        },

        "platformSpecific": {
            "JS_WEB": {
                "clientExtraCompatibilityFlag": true // actually doesn't matter for 3.5 -> 3.5
            }
        },

        "steps": {
            0: {
                "actor": ["subscribe", channelA, 0],
                "listener": ["join", channelA, 5]
            },

            1: {
                "actor": ["subscribe", channelB, 5],

                "listener": [
                    ["leave", channelA, 5],
                    ["join", channelA, 5],
                    ["join", channelB, 5]
                ]
            },

            2: {
                "actor": ["unsubscribe", channelA, 5],
                "listener": [
                    ["leave", channelA, 5],
                    ["leave", channelB, 5],
                    ["join", channelB, 5]
                ]
            }
        }
    }
};

function loadPNLib() {
    if (typeof PUBNUB === 'undefined') {

        console.log("PN is not loaded. Trying to load.");
        if (clientLevel == "3.6") {
            if (ssl) {
                url = "https://s3.amazonaws.com/pubnub/pubnub-3.6.0-beta.js";
            }
            else {
                url = "http://s3.amazonaws.com/pubnub/pubnub-3.6.0-beta.js";
            }
        }
        else if (clientLevel == "3.5") {
            if (ssl) {
                url = "https://s3.amazonaws.com/pubnub/pubnub-3.5.48.min.js";
            }
            else {
                url = "http://s3.amazonaws.com/pubnub/pubnub-3.5.48.min.js";
            }
        }
        else {
            console.log("ERROR! Could not determine proper JS to load.");
        }

        var fileref = document.createElement('script');
        fileref.setAttribute("type", "text/javascript");
        fileref.setAttribute("src", url);

        if (typeof fileref != "undefined")
            document.getElementsByTagName("head")[0].appendChild(fileref)

        fileref.onload = function (e) {
            console.log("Pn is now Loaded!");
            pnLoading = false;
        }

        pnLoadedInterval = setInterval(waitForPNLoad, 1000);

    } else {
        console.log("PN is already loaded.");
        pnLoading = false;
        waitForPNLoad();
    }
}

function pnInit(ssl, key, isListener) {

    var uuid = isListener ? listenerUUID : actorUUID;
    var origin = (clientLevel == "3.6") ? "presence-beta.pubnub.com" : "pubsub.pubnub.com";

    var pubnub = PUBNUB.init({
        publish_key: 'demo',
        subscribe_key: key,
        origin: origin,
        ssl: ssl,
        "compatible_3.5": extraCompat,
        uuid: uuid
    });

    console.log(uuid + ": " + key + "\nOrigin: " + origin + "\nClient level: " + clientLevel + "\nServer level: " + serverLevel + "\nCompat: " + true + "\nClient extra compat flag: " + extraCompat + "\nSSL: " + ssl);
    return pubnub;
}

function waitForPNLoad() {
    if (pnLoading) {
        console.log("Waiting for PN to finish loading.");
        pnLoadedInterval = setInterval(waitForPNLoad, 1000);
    } else {
        console.log("Initializing listener and actor instances.");
        clearInterval(pnLoadedInterval);

        randomSuffix = Math.floor((Math.random() * 10000) + 1);

        actorUUID = actorUUID + randomSuffix;
        listenerUUID = listenerUUID + randomSuffix;

        listener = pnInit(ssl, subKey, true);
        actor = pnInit(ssl, subKey, false);

        startCurrentTest();

    }
}

function initTest(testNub) {
    console.log("Running test: " + testNub.description);
    currentTest = testNub;
    ssl = testNub.common.ssl;
    clientLevel = testNub.common.client;
    serverLevel = testNub.common.server;
    pubKey = testNub.common.keyset.pubKey;
    subKey = testNub.common.keyset.subKey;
    extraCompat = testNub.platformSpecific.JS_WEB.clientExtraCompatibilityFlag;
    listenerInit = testNub.init.listener;

    loadPNLib();

}

function waitForTestInProgress(){

    console.log("111");
    if (testInProgress) {
        console.log("Still waiting for test to complete.");

    } else {
        clearInterval(testInProgressInterval);
        console.log("Test in progress complete.");
    }

}

function startCurrentTest() {
    var steps = currentTest.steps;
    var numberOfSteps = Object.keys(steps).length;

    console.log("Initiating test sequence for " + currentTest.common.description);

    //for (var a = 0; a < numberOfSteps; a++) {

    a = 0;

    currentStep = a;

        console.log("\nStep " + (a + 1) + " of " + numberOfSteps);

        var actorDelay = steps[a].actor[2];
        var actorAction = steps[a].actor[0];
        var actorChannel = steps[a].actor[1];

        var listenerTimeout = steps[a].listener[2];
        var listenerExpectedEvent = steps[a].listener[0];
        var listenerChannel = steps[a].listener[1];

        console.log("Actor should wait " + actorDelay + " seconds to " + actorAction + " to channel " + actorChannel);
        console.log("-- Then --");
        console.log("Listener should wait up to " + listenerTimeout + " seconds to receive a " + listenerExpectedEvent + " on channel " + listenerChannel);

    testInProgressInterval = setInterval(waitForTestInProgress, 5000);

    // TODO: Step Timeout
    //testTimeout = setTimeout(timeoutTest, (listenerTimeout * 1000));

    if (actorAction == "subscribe") {
            setTimeout(function () {
                initListenerAndSubscribeActorToChannel(actorChannel)
            }, actorDelay);
        }


    //}

}

initTest(tests["35_35_SSL_OFF"]);


function onActorPresenceEvent(msg, e, ch) {
    if (msg.uuid != listenerUUID && msg.uuid == actorUUID) {
        console.log("Listener heard Presence event: " + msg.action + " on " + msg.uuid + ": " + ch);
        var listener = currentTest.steps[0].listener;

        if (listener[0] == msg.action && listener[1] == ch && actorUUID == msg.uuid) {
            console.log("Step PASSED: " + currentStep);
            testInProgress = false;
        }

        var a = 0;
    }
}

function onChannelMessage(m) {
    console.log("Listener heard Message: " + m);
}

function actorSubscribe(channel) {
    actor.subscribe({
        noheresync: true,
        channel: channel,
        message: function (m) {
            console.log("Actor: msg received: " + m);
        },
        connect: function () {
            console.log("Actor: Connected");
        }
    });
}

function initListenerAndSubscribeActorToChannel(actorChannel) {
    listener.subscribe({
        noheresync: true,
        channel: listenerInit[1],
        message: onChannelMessage,
        presence: onActorPresenceEvent,
        connect: actorSubscribe(actorChannel)
    });
}

// UnSubToA


function unSubTo(channel) {
    actor.unsubscribe({
        channel: channel
    });


    listener.unsubscribe({
        channel: channel
    });

}

</script>


</html>
