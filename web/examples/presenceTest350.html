<html>
<script>

var maxWaitTime = 0;
var alreadyConnected = false;
var testResults = [];
var stepInProgress = true;
var stepInProgressInterval = 0;
var pnLoading = true;
var channelA = "gecA";
var channelB = "gecB";

var listenerInit = "";
var randomSuffix = "";
var currentTest = "";
var currentStep = "";
var ssl = false;
var clientLevel = "";
var serverLevel = "";

var pubKey = "";
var subKey = "";

var listenerUUID = "PN_LISTENER";
var actorUUID = "PN_ACTOR";

var pnLoadedInterval = "";
var listener = "";
var actor = "";
var extraCompat = "";

var currentStep = 0;
var currentTest = 0;
var numberOfSteps = 0;


var keysets = {

    "keyset1": {
        "pubKey": "pub-c-fb5fa283-0d93-424f-bf86-d9aca2366c86",
        "subKey": "sub-c-d247d250-9dbd-11e3-8008-02ee2ddab7fe",
        "secKey": "sec-c-MmI2YjRjODAtNWU5My00ZmZjLTg0MzUtZGM1NGExNjJkNjg1",
        "description": "Compatibility Mode ON"
    },

    "keyset2": {
        "pubKey": "pub-c-c9b0fe21-4ae1-433b-b766-62667cee65ef",
        "subKey": "sub-c-d91ee366-9dbd-11e3-a759-02ee2ddab7fe",
        "secKey": "sec-c-ZDUxZGEyNmItZjY4Ny00MjJmLWE0MjQtZTQyMDM0NTY2MDVk",
        "description": "Compatibility Mode OFF"
    }
};

var tests = [];
var test_1 = {


    "common": {
        "description": "3.5 -> 3.5 Base Compatibility, SSL Off.",
        "client": "3.5",
        "server": "3.5",
        "keyset": keysets.keyset1,
        "ssl": false,
        "maxSteps": 3
    },

    "init": {
        "listener": ["subscribe", [channelA, channelB], 0]
    },

    "platformSpecific": {
        "JS_WEB": {
            "clientExtraCompatibilityFlag": true // actually doesn't matter for 3.5 -> 3.5
        }
    },

    "steps": {
        0: {
            "actor": ["subscribe", channelA, 0],
            "listener": [
                ["join", channelA, 5000]
            ]                  // [should get this event, on channel ch, within this many seconds]
        },

        1: {
            "actor": ["subscribe", channelB, 0],

            "listener": [
                ["leave", channelA, 5000],
                ["join", channelA, 5000],
                ["join", channelB, 5000]
            ]                                               // when more than two rules are in an array, they:
            // can happen in any order
            // must both happen, in order for that step to pass
        },

        2: {
            "actor": ["unsubscribe", channelA, 0],
            "listener": [
                ["leave", channelA, 5000],
                ["leave", channelB, 5000],
                ["join", channelB, 5000]
            ]
        }
    }

};

tests.push(test_1);


function loadPNLib() {
    if (typeof PUBNUB === 'undefined') {

        console.log("PN is not loaded. Trying to load.");
        if (clientLevel == "3.6") {
            if (ssl) {
                url = "https://s3.amazonaws.com/pubnub/pubnub-3.6.0-beta.js";
            }
            else {
                url = "http://s3.amazonaws.com/pubnub/pubnub-3.6.0-beta.js";
            }
        }
        else if (clientLevel == "3.5") {
            if (ssl) {
                url = "https://s3.amazonaws.com/pubnub/pubnub-3.5.48.min.js";
            }
            else {
                url = "http://s3.amazonaws.com/pubnub/pubnub-3.5.48.min.js";
            }
        }
        else {
            console.log("ERROR! Could not determine proper JS to load.");
        }

        var fileref = document.createElement('script');
        fileref.setAttribute("type", "text/javascript");
        fileref.setAttribute("src", url);

        if (typeof fileref != "undefined")
            document.getElementsByTagName("head")[0].appendChild(fileref)

        fileref.onload = function (e) {
            console.log("Pn is now Loaded!");
            pnLoading = false;
        }

        pnLoadedInterval = setInterval(waitForPNLoad, 1000);

    } else {
        console.log("PN is already loaded.");
        pnLoading = false;
        waitForPNLoad();
    }
}

function pnInit(ssl, key, isListener) {

    var uuid = isListener ? listenerUUID : actorUUID;
    var origin = (serverLevel == "3.6") ? "presence-beta.pubnub.com" : "pubsub.pubnub.com";

    var pubnub = PUBNUB.init({
        publish_key: 'demo',
        subscribe_key: key,
        origin: origin,
        ssl: ssl,
        "compatible_3.5": extraCompat,
        uuid: uuid
    });

    console.log(uuid + ": " + key + "\nOrigin: " + origin + "\nClient level: " + clientLevel + "\nServer level: " + serverLevel + "\nCompat: " + true + "\nClient extra compat flag: " + extraCompat + "\nSSL: " + ssl);
    return pubnub;
}

function waitForPNLoad() {
    if (pnLoading) {
        console.log("Waiting for PN to finish loading.");
        pnLoadedInterval = setInterval(waitForPNLoad, 1000);
    } else {
        console.log("\nInitializing listener and actor instances.");
        clearInterval(pnLoadedInterval);

        randomSuffix = Math.floor((Math.random() * 10000) + 1);

        actorUUID = actorUUID + randomSuffix;
        listenerUUID = listenerUUID + randomSuffix;

        listener = pnInit(ssl, subKey, true);
        actor = pnInit(ssl, subKey, false);

        startCurrentTest();
    }
}

function initTest(testNub) {
    console.log("Running test: " + testNub.common.description + "\n");
    currentTest = testNub;
    ssl = testNub.common.ssl;
    clientLevel = testNub.common.client;
    serverLevel = testNub.common.server;
    pubKey = testNub.common.keyset.pubKey;
    subKey = testNub.common.keyset.subKey;
    extraCompat = testNub.platformSpecific.JS_WEB.clientExtraCompatibilityFlag;
    listenerInit = testNub.init.listener;

    loadPNLib();
}

function waitForStepInProgress() {

    if (stepInProgress) {
        console.log("Still waiting for test to complete.");

    } else {
        clearInterval(stepInProgressInterval);

        console.log("\n" + new Date + ": step " + currentStep + " complete.");

        if (!testResults[currentStep]) {
            testResults.push([
                {step: currentStep, action: "none", uuid: "none", timestamp: "none", date: new Date}
            ]);
        }

        for (a = 0; a < testResults[currentStep].length; a++) {
            var stringResults = JSON.stringify(testResults[currentStep][a]);
            console.log("\nStep " + currentStep + " results: " + stringResults + "\n");
        }

        currentStep++;
        startNextStep();
    }
}

function startCurrentTest() {
    console.log("\nStarting test: " + currentTest.common.description);
    alreadyConnected = false;
    numberOfSteps = Object.keys(currentTest.steps).length;

    startNextStep();
}

function logResultSummary() {
    for (step = 0; step < testResults.length; step++) {
        for (result = 0; result < testResults[step].length; result++) {
            stringResult = JSON.stringify(testResults[step][result]);
            console.log(stringResult);
        }
    }
}

function startNextStep() {

    stepInProgress = true;
    maxWaitTime = 0;

    if (currentStep + 1 > numberOfSteps) {
        console.log("\n*** All Test Steps Complete! ***\n");

        console.log("\nSummary of test results:");
        logResultSummary();
        return;
    }

    console.log("\nStep " + (currentStep) + ".");

    var actorDelay = currentTest.steps[currentStep].actor[2];
    var actorAction = currentTest.steps[currentStep].actor[0];
    var actorChannel = currentTest.steps[currentStep].actor[1];

    console.log("\nActor should wait " + actorDelay + " seconds to " + actorAction + " to channel " + actorChannel);
    console.log("-- Then --");

    for (a = 0; a < currentTest.steps[currentStep].listener.length; a++) {

        var listenerTimeout = currentTest.steps[currentStep].listener[a][2];
        var listenerExpectedEvent = currentTest.steps[currentStep].listener[a][0];
        var listenerChannel = currentTest.steps[currentStep].listener[a][1];

        console.log("Listener should wait up to " + listenerTimeout + " ms to receive a " + listenerExpectedEvent + " on channel " + listenerChannel);
        if (listenerTimeout > maxWaitTime) {
            maxWaitTime = listenerTimeout;
        }
    }

    console.log("maxWaitTime set to: " + maxWaitTime + "\n");

    stepInProgressInterval = setInterval(waitForStepInProgress, 1000);

    setTimeout(function () {
        stepInProgress = false;
    }, maxWaitTime);

    console.log("\n" + new Date + ": Starting step " + currentStep);

    if (currentStep == 0) {
        var initListener = true;
    } else {
        var initListener = false;
    }

    if (actorAction == "subscribe") {
        subscribeToChannel(actorChannel, initListener)
    } else if (actorAction == "unsubscribe") {
        unsubscribeToChannel(actorChannel, initListener)
    }
}

/* UNSUBSCRIBE */

function unsubscribeToChannel(actorChannel, initListener) {
    if (initListener) {

        // Spawn the listener, then the actor
        listener.subscribe({
            noheresync: true,
            channel: listenerInit[1],
            message: onActorChannelMessage,
            presence: onActorPresenceEvent,
            connect: function (ch) {
                if (alreadyConnected) {
                    console.log("Listener is already connected. Not doing that again.");
                    return;
                }

                alreadyConnected = true;
                console.log("Listener Connected.");
                actorUnsubscribe(actorChannel)
            }
        });
    } else {
        // Just spawn the actor
        actorUnsubscribe(actorChannel)
    }
}

function actorUnsubscribe(channel) {
    console.log("Unsubscribing actor...");
    actor.unsubscribe({
        channel: channel
    });
}


/* SUBSCRIBE */

function subscribeToChannel(actorChannel, initListener) {
    if (initListener) {

        // Spawn the listener, then the actor
        listener.subscribe({
            noheresync: true,
            channel: listenerInit[1],
            message: onActorChannelMessage,
            presence: onActorPresenceEvent,
            connect: function (ch) {
                if (alreadyConnected) {
                    console.log("Listener is already connected. Not doing that again.");
                    return;
                }

                alreadyConnected = true;
                console.log("Listener Connected.");
                actorSubscribe(actorChannel)
            }
        });
    } else {
        // Just spawn the actor
        actorSubscribe(actorChannel)
    }
}

function actorSubscribe(channel) {
    console.log("Subscribing actor...");
    actor.subscribe({
        noheresync: true,
        channel: channel,
        message: function (m) {
            console.log("Actor: msg received: " + m);
        },
        connect: function () {
            console.log("Actor: Subscribe complete on channel " + channel + ".");
        }
    });
}

// This is what the listener calls when he hears an event
function onActorPresenceEvent(msg, e, ch) {
    if (msg.uuid != listenerUUID && msg.uuid == actorUUID) {
        console.log("Listener heard Presence event: " + msg.action + " on " + msg.uuid + ": " + ch);

        if (!testResults[currentStep]) {
            testResults.push([]);
        }

        testResults[currentStep].push({step: currentStep, action: msg.action, uuid: msg.uuid, timestamp: msg.timestamp, date: new Date });
    }
}

function onActorChannelMessage(m) {
    console.log("Listener heard Message: " + m);
}


/* Start! */

initTest(test_1);

</script>


</html>
